Что нам привносит ECMAScript 6?

№1

ОПРОС
Знакома ли вам такая синтаксическая конструкция?

```
function propertyInitializerGetterSetter() {
    var _x = 0;

    return {
        get x() { return _x; },
        set x(value) { _x = value; }
    };
}
```

Юзаем
Видели
Незнакома

№2

Его добавили в ECMAScript 5, называется
getters and setters in property initializer.

Если вдруг захотите заюзать, и вам не нужна поддержка восьмого
Internet Explorer, то можете смело это делать.

Так вот, господа, это одно из немногих изменений синтаксиса
JavaScript за последние 15 лет.

№3

Сложно поверить, что сайты...

№4

и эти сайты ....

№5

и это притом что JavaScript был написан за 10 дней.

№6

как многие знают, Бренданом Айком в Netscape в 1995 году

так откуда взялось слово ECMAScript?

№7

слайд про Sun, Microsoft

№8

ECMA Comittee

№9

ES4

№10

Итак, как это вернулось на круги своя?
TC39 - лучшие эксперты из Google, Microsoft, Mozila, ...

№11

И чего они все хотят?
Сделать JavaScript лучше, безопаснее, поддерживаемее и мощнее тоже.

№12

Но не сломать веб.
Даже если какая-то особенность языка выносит мозг новичкам
и может даже старичкам, то не трогать ее — да кривая, да плохая,
но пусть остается.

Взамен мы просто добавим конструкцию получше, побезопаснее, которая
в будущем может и вытеснит старые конструкции.

№13

В первую очередь, это касается всплытия в JavaScript.
Пускай оно отокроет TOP 5 WTF в JS:

```
function hoisting() {
    x = 5;
    console.log(x); // 5
    var x;
}
```

То, что вы видите — вполне валидная конструкция.
Но она вызывает боль у людей, которые ее видят.
ECMAScript 6 добавляет новое ключевое слово let,
чтобы не уменшить эту боль.

```
function noHoistingAnymore() {
    x = 5;

// ReferenceError: can't
// access lexical declaration
// `x' before initialization

    let x;
}
```

№14

Давайте еще посмотрим классический пример на собеседованиях
 с замыканиями, выносящий мозг тем, кто приходит с других языков.

```
```

JSHint ругается на такое.
(мужик блеать: Don't make functions within loop)

Почему мы нам в консоль насыпется куча девяток, хотя 
вроде как мы внутри блока цикла объявили переменную?

№15

Потому что на самом деле, интерпретатор видит все это так.
```
```

И обращается к общей для всех переменной, которая в конце равна 9.

Нельзя просто взять и объявить переменную на уровне отдельного
блока, ее все равно выносит наверх.

№16

Но с let жизнь начинается заново.

```
```

Наш пример заработает, и каждая функция выведет свое число.
Потому что каждый раз создается своя настоящая переменная,
для каждой функции, создаваемой в цикле.
Ура!

№17

Иногда очень не хватало в языке констант.
Теперь их добавили, по принципу работы они идентичны на let,
то есть не всплывают наверх.
И не дают переприсвоить себя.

```
const X = 5;
X = 6;
console.log(X);
```

ОПРОС

На самом деле, все три варианта ответа правильные.
Сегодня все браузеры, начиная с IE11 понимают это ключевое слово.
Но некоторые интерпретируют это как обычный var, например Safari.
Конечно, позже, поддержку допилят, и только первый и вторый вариант
останутся правильными.

```
'use strict';
const X = 5;
X = 6;
```

Посыпется ошибка только тогда, когда включен 'strict mode'.

№17

```
'use strict';

const foo = {
    bar: "hello",
};

foo.bar = "salut";
```

Но не надо думать, что константа вам помешает сделать переприсвоение в самом объекте.
Если вы хотите запретить именно такое поведение, то у меня есть для вас хорошие новости.

№18

```
'use strict';

var foo = Object.freeze({
    bar: "hello"
});
```

Это называется замораживание объектов, и оно давно уже доступно везде,
так как было введено еще в ECMAScript 5.

Раньше использование такой конструкции замедляло работу с объектами, (смотреть java
но это был баг, и в Chrome какой-то версии это исправили и замороженные объекты
стали шустрее обычных аж на 25%.

http://stackoverflow.com/questions/8435080/any-performance-benefit-to-locking-down-javascript-objects

№19

WHERE ARE MY
LAMBDA EXPRESSIONS?

CoffeeScript: ->, =>
Java: ->
C#: =>
Ruby: lambda { }
Python: lambda x:

Лямбда-выражения появились везде, даже в Джаве.
Люди переходят на Кофискрипт, потому что хочется
компактной формы записи

№20

```
[1, 2, 3].map(x => x * x);
// [1, 4, 9]

[1, 2, 3].map((x, i) => {
    return x * i;
});
// [0, 2, 6]

В ECMAScript 6 это назвали стрелочными функциями,
и через время такое будет доступно повсюду.
И уже доступно на сервер-сайде Node.js, и в Firefox.

№21

var that = this
===============

```
this.x = 5;
/* ... */
var that = this;
setTimeout(function () {
    console.log(that.x);
}, 1000);
```

Я думаю почти все писали когда-либо эту конструкцию.

Прийдя с других языков программирования, люди долго вкуривают
ключевое слово this, потому что это не тот this, к которому
привыкаешь в ООП.

№22

```
setTimeout(function () {
    console.log(that.x);
}.bind(this), 1000);
```

В ECMAScript 5 появился метод bind, чтобы задать контекст, и можно
обойтись без замыканий.

№23

```
this.x = 5;
setTimeout(() => console.log(this.x), 1000);
```

Но в ECMAScript 6 с помощью стрелочных функций можно решить все изящнее.
У таких функций автоматически берут свой this из того контекста, где были объявлены.
Для CoffeeScript-ров это означает, что не thin arrow function, а это fat arrow functions.

№24

PRIVACY PROBLEM

№25

```
function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype.distanceTo = function (point) {
    var dx = point.x - this.x;
    var dy = point.y - this.y;

    return Math.sqrt(dx*dx + dy*dy);
}
```

Рано или поздно разработчики сталкиваются с необходимостью
не выставлять какие-то поля объектов наружу.

Но в JavaScript'е это не так и просто.

Рассмотрим это на примере.
Есть конструктор точки с двумя координатами X, Y.
И у любой точки есть метод посчитать расстояние до другой
точки.

Например, мы хотим скрыть координаты x, y от взора
других любопытных коллег. Сделать полностью! приватными.

И не добавлять никаких других методов.

№26

```
function Point(x, y) {
    this.getDistanceTo = (point) => {
        var dx = point.x - x;
        // point.x === undefined
    };
}
```

Распространенный способ скрытия — это спрятать
переменные в замыкании.

Очень нехорошо то, что я буду каждый раз создавать
новую функцию при конструировании точки.

Ну да ладно, пожертвуем памятью и красотой ради
приватности.

Но есть другая проблема, я не могу доступиться к
x у другого объекта.

Как выйти из этого положения, не добавляя никаких
дополнительных методов и свойств?

№27

```
var X_KEY = '__x__' + Math.random(),
    Y_KEY = '__y__' + Math.random(); 

function Point(x, y) {
    Object.defineProperty(this, X_KEY, { value: x });
    Object.defineProperty(this, Y_KEY, { value: y });
}

Point.prototype.distanceTo = function (point) {
    var dx = point[X_KEY] - this[X_KEY];
    // ...
}
```

Если мы добавим свойство с каким-то случайным названием,
то к нему нельзя будет обратиться, не зная его в точности.

И даже угадав его, при следующем перезапуске программы,
оно изменится, и даст эту приватность.

Свойства объявленные через defineProperty, по умолчанию
нельзя перечислить for-in, нельзя получить с помощью
Object.keys.

№28

Symbols in ES6

```
var KEY_X = new Symbol(),
    KEY_Y = new Symbol();

function Point(x, y) {
    this[KEY_X] = x;
    this[KEY_Y] = y;
}

Point.prototype.distanceTo = function (point) {
    var dx = point[KEY_X] - this[KEY_X];
    // ...
}
```

ES6 вводит понятие символов, они очень похожи на строки,
но вот такие рандомные, приватные. 

Они не совсем похожи на символы в Руби,
так как основная задача - обеспечение приватности. 

Такие символьные свойства не перечисляемы в цикле for-in. 
 
Это у вас нет ссылки на символ,
то из объекта вы не вытянете значение,
записанное по этому символу.

Хотя лазейки, конечно, существуют, можете поискать. 

№29 

Если мы вернемся снова к проблеме с замыканием и приватностью,
то должен сказать - признаюсь, слукавил.

Решить можно, и изящнее всего этого можно достичь с помощью нового типа WeakMap.
Если мы успеем, и у вас будет желание, можем рассмотреть и этот вариант. 

#30 

Но наверняка вы уже слышали и видели, что в ES6 появляются классы. 
Неужели нельзя с их помощью решить задачу? 
Давайте посмотрим как может выглядеть Point в class-syntax.

#31 

```
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    distanceTo(point) {
        var dx = point.x - this.x;
        var dy = point.y - this.y;

        return Math.sqrt(dx*dx + dy*dy);
    }
}
```

Выглядит довольно симпатично, обратите внимание,
что объявления в классе не разделяются запятыми.

Что важно понимать?
В статьях про ECMAScript 6 классы рекомендуют не забывать
одной такой вещи — что классы, это тонкая надстройка над
прототипным наследованием, и все, что можно описать классами,
то можно описать и прототипами.

А это означает, что приватные поля объявить нельзя.
Рекомендуется для таких целей использовать символы или замыкания.

Но давайте посмотрим что есть.

# 32

А есть наследование.
```
```
тут можно почувствовать, что на прототипах сделать наследование
более трудоемкая задача.

# 33

Как использовать это все богатство сейчас?



